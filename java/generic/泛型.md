## 一、什么是泛型

#### 1.背景：

JAVA推出泛型以前，程序员可以构建一个元素类型为Object的集合，该集合能够存储任意的数据类型对象，而在使用该集合的过程中，需要程序员明确知道存储每个元素的数据类型，否则很容易引发ClassCastException异常。

#### 2.概念：

Java泛型（generics）是JDK5中引入的一个新特性，泛型提供了编译时类型安全监测机制，该机制允许我们在编译时检测到非法的类型数据结构。泛型的本质就是参数化类型，也就是所操作的数据类型被指定为一个参数。

#### 3.好处：

- 类型安全
- 消除了强制类型的转换

#### 4.类型：

- E - Element (在集合中使用，因为集合中存放的是元素)
- T - Type（表示Java 类，包括基本的类和我们自定义的类）
- K - Key（表示键，比如Map中的key）
- V - Value（表示值）
- N - Number（表示数值类型）
- ？ - （表示不确定的java类型）
- S、U、V - 2nd、3rd、4th types

## 二、泛型类、接口

#### 1.泛型类

（1）使用语法
类名<具体的数据类型> 对象名 = new 类名<具体的数据类型>();

（2）Java1.7以后，后面的<>中的具体的数据类型可以省略不写
类名<具体的数据类型> 对象名 = new 类名<>(); `菱形语法`

### 2.泛型类注意事项：

- 泛型类，如果没有指定具体的数据类型，此时，操作类型是Object
- 泛型的类型参数只能是类类型，不能是基本数据类型
- 泛型类型在逻辑上可以看成是多个不同的类型，但实际上都是相同类型

定义一个泛型类

```java
public class Generic<T> {
    private T key;


    @Override
    public String
    toString() {
        return "Generic{" +
                "key=" + key +
                '}';
    }

    public Generic() {
    }

    public Generic(T key) {
        this.key = key;
    }

    public T getKey() {
        return key;
    }

    public void setKey(T key) {
        this.key = key;
    }
}
```

test类

```java
        Generic<String> stringGeneric = new Generic<String>();
        stringGeneric.setKey("1");
        String key = stringGeneric.getKey();
        System.out.println(key);

        Generic<Integer> integerGeneric = new Generic<Integer>();
        integerGeneric.setKey(1);
        System.out.println(1);

        Generic generic = new Generic();
        generic.setKey(1);//不指定泛型为Object类型

        //泛型类不支持基本数据类型
//        Generic<int> generic1 = new Generic<int>();

        //统一泛型类根据不同的的数据类型创建的对象本质上是同一个对象
        System.out.println(stringGeneric.getClass() == integerGeneric.getClass());//true
```

#### 3.从泛型类派生子类

- 子类也是泛型类，子类和父类的泛型类型要一致
  `class ChildGeneric extends Generic`

```java
//父类
public class Parent<E> {
    private E value;
    public E getValue() {
        return value;
    }
    public void setValue(E value) {
        this.value = value;
    }
}

/**
 * 泛型类派生子类，子类也是泛型类，那么子类的泛型标识要和父类一致。
 * 子类的泛型可以是多个
 * @param <T>
 */
public class ChildFirst<T> extends Parent<T> {
    @Override
    public T getValue() {
        return super.getValue();
    }
}
```

- 子类不是泛型类，父类要明确泛型的数据类型
  `class ChildGeneric extends Generic`

```java
/**
 * 泛型类派生子类，如果子类不是泛型类，那么父类要明确数据类型
 */
public class ChildSecond extends Parent<Integer> {
    @Override
    public Integer getValue() {
        return super.getValue();
    }
    @Override
    public void setValue(Integer value) {
        super.setValue(value);
    }
}
```

#### 4.泛型接口

**泛型接口的定义语法：**

```java
interface 接口名称 <泛型标识，泛型标识，…> {
	泛型标识 方法名(); 
	.....
}
```

#### 5.泛型接口的使用

- 实现类不是泛型类，接口要明确数据类型

```java
/**
 * 实现泛型接口的类，不是泛型类，需要明确实现泛型接口的数据类型。
 */
public class Apple implements Generator<String> {
    @Override
    public String getKey() {
        return "hello generic";
    }
}
```

- 实现类也是泛型类，实现类和接口的泛型类型要一致

```java
/**
 * 泛型接口
 * @param <T>
 */
public interface Generator<T> {
    T getKey();
}
/**
 * 泛型接口的实现类，是一个泛型类，
 * 那么要保证实现接口的泛型类泛型标识包含泛型接口的泛型标识
 * @param <T>
 * @param <E>
 */
public class Pair<T,E> implements Generator<T> {

    private T key;
    private E value;

    public Pair(T key, E value) {
        this.key = key;
        this.value = value;
    }

    @Override
    public T getKey() {
        return key;
    }

    public E getValue() {
        return value;
    }
}
```

## 三、泛型方法

#### 1.用法

泛型方法是在调用方法的时候指明泛型的具体类型。

#### 2.语法:

```
修饰符  返回值类型 方法名(形参列表) { 方法体... }
```

#### 3.说明：

- public与返回值中间< T >非常重要，可以理解为声明此方法为泛型方法。
- 只有声明了< T >的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。
- < T >表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。
- 与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。

#### 4.泛型方法与可变参数

```java
public <E> void print(E... e){
	for (E e1 : e) {
		System.out.println(e);
	}
}

//可变参数指的是参数可以随便指定
//Apple.print(1,2,3,4,5);
//Apple.print("a","b","c","d","e");
```

#### 5.泛型方法总结

- 泛型方法能使方法独立于类而产生变化
- 如果static方法要使用泛型能力，就必须使其成为泛型方法

```java
 /**
     * 静态的泛型方法，采用多个泛型类型
     * @param t
     * @param e
     * @param k
     * @param <T>
     * @param <E>
     * @param <K>
     */
    public static <T,E,K> void printType(T t, E e, K k) {
        System.out.println(t + "\t" + t.getClass().getSimpleName());
        System.out.println(e + "\t" + e.getClass().getSimpleName());
        System.out.println(k + "\t" + k.getClass().getSimpleName());
    }

```

## 四、类型通配符

#### 1.什么是类型通配符

- 类型通配符一般是使用"?"代替具体的类型实参。
- 所以，类型通配符是类型实参，而不是类型形参。

```java
public class Test {
    public static void main(String[] args) {
        Box<Number> box = new Box<Number>();
        box.setFirst(100);
        showBox(box);

//        泛型里的类型不能多态 虽然Integer继承自Number,但是不能表现为多态
//        Box<Integer> box1 = new Box<Integer>();
//        box1.setFirst(10);
//        showBox(box1);

    }

    public static  void  showBox(Box<Number> box) {
        Number first = box.getFirst();
        System.out.println(first);
    }
    
//可以通过统配符?来表示
    public static  void  showBox1(Box<? extends Number> box) {
        Object first = box.getFirst();
        System.out.println(first);
    }
}    
```



#### 2.类型通配符的上限

- 语法：
  `类/接口`<? extend 实参类型>
  要求该泛型的类型，只能是实参类型，或实参类型的子类类型。

```java
public static  void  showBox1(Box<? extends Number> box) {
    Object first = box.getFirst();
    System.out.println(first);
}
```

#### 3.类型通配符的下限

- 语法：
   类/接口<? super 实参类型> 
  要求该泛型的类型，只能是实参类型，或实参类型的父类类型。

```java
public static  void  showBox1(Box<? super Integer> box) {
    Object first = box.getFirst();
    System.out.println(first);
}
```



## 五、类型擦除

#### 1.概念

泛型是Java 1.5版本才引进的概念，在这之前是没有泛型的，但是泛型代码能够很好地和之前版本的代码兼容。那是因为，泛型信息只存在于代码编译阶段，在进入JVM之前，与泛型相关的信息会被擦除掉，我们称之为–类型擦除。

#### 2.分类：

- 无限制类型擦除
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200702220929327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JleW9uZGN6bg==,size_16,color_FFFFFF,t_70)
- 有限制类型擦除
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200702221003157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JleW9uZGN6bg==,size_16,color_FFFFFF,t_70)
- 擦除方法中类型定义的参数
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200702221026746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JleW9uZGN6bg==,size_16,color_FFFFFF,t_70)
- 桥接方法
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200702221100946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JleW9uZGN6bg==,size_16,color_FFFFFF,t_70)

## 六、泛型与数组

**泛型数组的创建**

- 可以声明带泛型的数组引用，但是不能直接创建带泛型的数组对象

```java
ArrayList<String>[] listArr = new ArrayList<5>(); //会报错
```

```java
ArrayList[] list = new ArrayList[5];
ArrayList<String>[] listArr = list; //不会报错
或者
ArrayList<String>[] listArr = new ArrayList[5];
```



- 可以通过java.lang.reflect.Array的newInstance(Class,int)创建T[]数组

```java
public class Fruit<T> {
    private T[] array;

    public Fruit(Class<T> clz, int length){
        //通过Array.newInstance创建泛型数组
        array = (T[])Array.newInstance(clz, length);
    }
}
```

## 七、泛型和反射

- 反射常用的泛型类
  Class< T >
  Constructor< T >

```java
public class Person {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
/**
 * 泛型与反射
 */
public class Test11 {
	public static void main(String[] args) throws Exception {
	     Class<Person> personClass = Person.class;
	     Constructor<Person> constructor = personClass.getConstructor();
	     Person person = constructor.newInstance();
	 }
}

```

